<?xml version="1.0" encoding="utf8"?>
<shader_source>
 <name>grass</name>
 <type>albedo_mapping</type>
 <shader_source_datas>
  <shader_source_data>
   <parameters>
    <parameter>
     <name>fragment_uv</name>
     <type>vec2</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>albedo_sampler_0</name>
     <type>sampler2D</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>albedo_sampler_1</name>
     <type>sampler2D</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>albedo_sampler_2</name>
     <type>sampler2D</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>albedo_sampler_3</name>
     <type>sampler2D</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>tbn_matrix</name>
     <type>mat3</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>world_view_direction</name>
     <type>vec4</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>albedo</name>
     <type>vec4</type>
     <qualifier>out</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>world_extra_uv</name>
     <type>vec2</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
   </parameters>
   <source>#define MAX_RAYDEPTH 5 //Number of iterations.

#define PLANE_NUM 16.0 //Number of grass slice grid planes per unit in tangent space.

#define PLANE_NUM_INV (1.0/PLANE_NUM)
#define PLANE_NUM_INV_DIV2 (PLANE_NUM_INV/2)

#define GRASS_SLICE_NUM 8 // Number of grass slices in texture grassblades.

#define GRASS_SLICE_NUM_INV (1.0/GRASS_SLICE_NUM)
#define GRASS_SLICE_NUM_INV_DIV2 (GRASS_SLICE_NUM_INV/2)

#define GRASSDEPTH GRASS_SLICE_NUM_INV //Depth set to inverse of number of grass slices so no stretching occurs.

#define TC1_TO_TC2_RATIO 8 //Ratio of texture coordinate set 1 to texture coordinate set 2, used for the animation lookup.

#define PREMULT (GRASS_SLICE_NUM_INV*PLANE_NUM) //Saves a multiply in the shader.

#define AVERAGE_COLOR vec4(0.32156,0.513725,0.0941176,1.0) //Used to fill remaining opacity, can be replaced by a texture lookup.

{
 	vec2 plane_offset;
 	vec3 ray_entry, view_dir;
	float zOffset;
	int i;

	//Initialize increments/decrements and per fragment constants
	albedo = vec4(0.0,0.0,0.0,0.0);

 	plane_offset = vec2(0.0,0.0);
 	ray_entry = vec3(fragment_uv,0.0);
	zOffset = 0.0;

	view_dir = world_view_direction.xyz * tbn_matrix;

 	//The signs of view_dir determines if we increment or decrement along the tangent space axis
	//plane_correct, planemod and pre_dir_correct are used to avoid unneccessary if-conditions.

 	vec2 sign = vec2(sign(view_dir.x),sign(view_dir.y));
 	vec2 plane_correct = vec2((sign.x+1)*GRASS_SLICE_NUM_INV_DIV2,
		(sign.y+1)*GRASS_SLICE_NUM_INV_DIV2);
 	vec2 planemod = vec2(floor(ray_entry.x*PLANE_NUM)/PLANE_NUM,
		floor(ray_entry.y*PLANE_NUM)/PLANE_NUM);
	vec2 pre_dir_correct = vec2((sign.x+1)*PLANE_NUM_INV_DIV2,
		(sign.y+1)*PLANE_NUM_INV_DIV2);

 	for (i = 0; i &lt; MAX_RAYDEPTH; ++i)
 	{

		//Calculate positions of the intersections with the next grid planes on the u,v tangent space axis independently.

 		vec2 dir_correct = vec2(sign.x*plane_offset.x+pre_dir_correct.x,
 		                            sign.y*plane_offset.y+pre_dir_correct.y);			
		vec2 distance = vec2((planemod.x + dir_correct.x - ray_entry.x)/(view_dir.x),
		                         (planemod.y + dir_correct.y - ray_entry.y)/(view_dir.y));

 		vec3 rayHitpointX = ray_entry + view_dir * distance.x;   
  		vec3 rayHitpointY = ray_entry + view_dir * distance.y;

		//Check if we hit the ground. If so, calculate the intersection and look up the ground texture and blend colors.

  		if ((rayHitpointX.z &lt;= -GRASSDEPTH) &amp;&amp; (rayHitpointY.z &lt;= -GRASSDEPTH)) 	
  		{
  			float distanceZ = (-GRASSDEPTH) / view_dir.z; // ray_entry.z is 0.0 anyway 

  			vec3 rayHitpointZ = ray_entry + view_dir * distanceZ;
			vec2 orthoLookupZ = vec2(rayHitpointZ.x,rayHitpointZ.y);
						
  			albedo += (1.0 - albedo.a) * texture2D(albedo_sampler_0,orthoLookupZ);
  			zOffset = distanceZ; // write the distance from ray_entry to intersection
  			break;	//Early exit here
  		}  
  		else
 		{
 			
 			vec2 orthoLookup; //Will contain texture lookup coordinates for grassblades texture.

 			//check if we hit a u or v plane, calculate lookup accordingly with wind shear displacement.
			if (distance.x &lt;= distance.y)
 			{
 				vec4 windX = (texture2D(albedo_sampler_3,world_extra_uv+rayHitpointX.xy/TC1_TO_TC2_RATIO)-0.5)/2;
				
				float lookupX = -(rayHitpointX.z+(planemod.x+sign.x*plane_offset.x)*PREMULT)-plane_correct.x;
				orthoLookup=vec2(rayHitpointX.y+windX.x*(GRASSDEPTH+rayHitpointX.z),lookupX); 
				
				plane_offset.x += PLANE_NUM_INV; // increment/decrement to next grid plane on u axis
				zOffset = distance.x;
			}
			else
			{
				vec4 windY = (texture2D(albedo_sampler_3,world_extra_uv+rayHitpointY.xy/TC1_TO_TC2_RATIO)-0.5)/2;
 			
				float lookupY = -(rayHitpointY.z+(planemod.y+sign.y*plane_offset.y)*PREMULT)-plane_correct.y;
				orthoLookup = vec2(rayHitpointY.x+windY.y*(GRASSDEPTH+rayHitpointY.z) ,lookupY);
 			
				plane_offset.y += PLANE_NUM_INV;  // increment/decrement to next grid plane on v axis
				zOffset = distance.y;	
  			}
  			 
 	 		albedo += (1.0 - albedo.a) * texture2D(albedo_sampler_1,orthoLookup);

 	 		if (albedo.a &gt;= 0.49)
			{
				  break;	//Early exit here
			}
  		}
	}	

     albedo += (1.0-albedo.a)*AVERAGE_COLOR; //Fill remaining transparency in case there is some left. Can be replaced by a texture lookup
					   //into a fully opaque grass slice using orthoLookup.

#if	0
     color.xyz *= (vertColor.xyz); //Modulate with per vertex lightmap,as an alternative, modulate with N*L for dynamic lighting.

     //zOffset is along eye direction, transform and add to vertex position to get correct z-value.
     positionViewProj += mul(worldViewProj,view_dir.xzy*zOffset); 

     //Divide by homogenous part.
     depth = positionView.z/positionView.w;
#endif
}
</source>
   <glsl_120>true</glsl_120>
   <glsl_130>false</glsl_130>
   <glsl_140>false</glsl_140>
   <glsl_150>false</glsl_150>
   <glsl_330>false</glsl_330>
  </shader_source_data>
  <shader_source_data>
   <parameters>
    <parameter>
     <name>fragment_uv</name>
     <type>vec2</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>albedo_sampler_0</name>
     <type>sampler2D</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>albedo_sampler_1</name>
     <type>sampler2D</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>albedo_sampler_2</name>
     <type>sampler2D</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>albedo_sampler_3</name>
     <type>sampler2D</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>tbn_matrix</name>
     <type>mat3</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>world_view_direction</name>
     <type>vec4</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>albedo</name>
     <type>vec4</type>
     <qualifier>out</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>world_extra_uv</name>
     <type>vec2</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>world_position</name>
     <type>vec3</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>projection_view_matrix</name>
     <type>mat4</type>
     <qualifier>in</qualifier>
     <size>layer_count</size>
     <scale>1</scale>
    </parameter>
   </parameters>
   <source>#define MAX_RAYDEPTH 5 //Number of iterations.

#define PLANE_NUM 4.0 //Number of grass slice grid planes per unit in tangent space.

#define PLANE_NUM_INV (1.0/PLANE_NUM)
#define PLANE_NUM_INV_DIV2 (PLANE_NUM_INV/2)

#define GRASS_SLICE_NUM 8 // Number of grass slices in texture grassblades.

#define GRASS_SLICE_NUM_INV (1.0/GRASS_SLICE_NUM)
#define GRASS_SLICE_NUM_INV_DIV2 (GRASS_SLICE_NUM_INV/2)

#define GRASSDEPTH GRASS_SLICE_NUM_INV //Depth set to inverse of number of grass slices so no stretching occurs.

#define TC1_TO_TC2_RATIO 8 //Ratio of texture coordinate set 1 to texture coordinate set 2, used for the animation lookup.

#define PREMULT (GRASS_SLICE_NUM_INV*PLANE_NUM) //Saves a multiply in the shader.

#define AVERAGE_COLOR vec4(0.32156,0.513725,0.0941176,1.0) //Used to fill remaining opacity, can be replaced by a texture lookup.

{
 	vec2 plane_offset;
 	vec3 ray_entry, view_dir;
	float zOffset;
	int i;

	//Initialize increments/decrements and per fragment constants
	albedo = vec4(0.0,0.0,0.0,0.0);

 	plane_offset = vec2(0.0,0.0);
 	ray_entry = vec3(fragment_uv,0.0);
	zOffset = 0.0;

	view_dir = world_view_direction.xyz * tbn_matrix;

 	//The signs of view_dir determines if we increment or decrement along the tangent space axis
	//plane_correct, planemod and pre_dir_correct are used to avoid unneccessary if-conditions.

 	vec2 sign = vec2(sign(view_dir.x),sign(view_dir.y));

 	vec2 plane_correct = vec2((sign.x+1)*GRASS_SLICE_NUM_INV_DIV2,
		(sign.y+1)*GRASS_SLICE_NUM_INV_DIV2);
 	vec2 planemod = vec2(floor(ray_entry.x*PLANE_NUM)/PLANE_NUM,
		floor(ray_entry.y*PLANE_NUM)/PLANE_NUM);
	vec2 pre_dir_correct = vec2((sign.x+1)*PLANE_NUM_INV_DIV2,
		(sign.y+1)*PLANE_NUM_INV_DIV2);

	vec2 uv_dx[2];
	vec2 uv_dy[2];

	uv_dx[0] = dFdx(fragment_uv);
	uv_dy[0] = dFdy(fragment_uv);
	uv_dx[1] = dFdx(world_extra_uv);
	uv_dy[1] = dFdy(world_extra_uv);

	int depth = 0;

 	for (i = 0; i &lt; MAX_RAYDEPTH; ++i)
 	{

		//Calculate positions of the intersections with the next grid planes on the u,v tangent space axis independently.

 		vec2 dir_correct = vec2(sign.x*plane_offset.x+pre_dir_correct.x,
 		                            sign.y*plane_offset.y+pre_dir_correct.y);			
		vec2 distance = vec2((planemod.x + dir_correct.x - ray_entry.x)/(view_dir.x),
		                         (planemod.y + dir_correct.y - ray_entry.y)/(view_dir.y));

 		vec3 rayHitpointX = ray_entry + view_dir * distance.x;   
  		vec3 rayHitpointY = ray_entry + view_dir * distance.y;
  		vec3 rayHitpointZ = ray_entry + view_dir * min(distance.x, distance.y);
/*
  		if ((rayHitpointZ.z &lt;= -GRASSDEPTH / 3) &amp;&amp; (depth &lt; 1))
  		{
			vec4 wind = (textureGrad(albedo_sampler_3,world_extra_uv * 0.5, uv_dx[1], uv_dy[1])-0.5)/2;
  			float distanceZ = (-GRASSDEPTH / 3) / view_dir.z; // ray_entry.z is 0.0 anyway

  			vec3 rayHitpointZ = ray_entry + view_dir * distanceZ;
			vec2 orthoLookupZ = vec2(rayHitpointZ.x,rayHitpointZ.y) + wind.xy * 0.05;
						
  			albedo += (1.0 - albedo.a) * textureGrad(albedo_sampler_2, orthoLookupZ, uv_dx[0], uv_dy[0]);
  			zOffset = distanceZ; // write the distance from ray_entry to intersection
  			depth = 1;
  		}

  		if ((rayHitpointZ.z &lt;= -GRASSDEPTH * 2 / 3) &amp;&amp; (depth &lt; 2))
  		{
			vec4 wind = (textureGrad(albedo_sampler_3,world_extra_uv * 0.5, uv_dx[1], uv_dy[1])-0.5)/2;
  			float distanceZ = (-GRASSDEPTH * 2 / 3) / view_dir.z; // ray_entry.z is 0.0 anyway

  			vec3 rayHitpointZ = ray_entry + view_dir * distanceZ;
			vec2 orthoLookupZ = vec2(rayHitpointZ.x,rayHitpointZ.y) + wind.xy * 0.05;
						
  			albedo += (1.0 - albedo.a) * textureGrad(albedo_sampler_2, orthoLookupZ.yx, uv_dx[0], uv_dy[0]);
  			zOffset = distanceZ; // write the distance from ray_entry to intersection
  			depth = 2;
  		}
*/
		//Check if we hit the ground. If so, calculate the intersection and look up the ground texture and blend colors.

		if ((rayHitpointX.z &lt;= -GRASSDEPTH) &amp;&amp; (rayHitpointY.z &lt;= -GRASSDEPTH))
		{
			float distanceZ = (-GRASSDEPTH) / view_dir.z; // ray_entry.z is 0.0 anyway 

			vec3 rayHitpointZ = ray_entry + view_dir * distanceZ;
			vec2 orthoLookupZ = vec2(rayHitpointZ.x,rayHitpointZ.y);
			
			albedo += (1.0 - albedo.a) * textureGrad(albedo_sampler_0,orthoLookupZ, uv_dx[0], uv_dy[0]);
			zOffset = distanceZ; // write the distance from ray_entry to intersection
			break;	//Early exit here
  		}
  		else
 		{
 			vec2 orthoLookup; //Will contain texture lookup coordinates for grassblades texture.

 			//check if we hit a u or v plane, calculate lookup accordingly with wind shear displacement.
			if (distance.x &lt;= distance.y)
 			{
 				vec4 windX = (textureGrad(albedo_sampler_3,world_extra_uv+rayHitpointX.xy/TC1_TO_TC2_RATIO, uv_dx[1], uv_dy[1])-0.5)/2;

				float lookupX = -(rayHitpointX.z+(planemod.x+sign.x*plane_offset.x)*PREMULT)-plane_correct.x;
				orthoLookup=vec2(rayHitpointX.y+windX.x*(GRASSDEPTH+rayHitpointX.z),lookupX); 
				
				plane_offset.x += PLANE_NUM_INV; // increment/decrement to next grid plane on u axis
				zOffset = distance.x;
			}
			else
			{
				vec4 windY = (textureGrad(albedo_sampler_3,world_extra_uv+rayHitpointY.xy/TC1_TO_TC2_RATIO, uv_dx[1], uv_dy[1])-0.5)/2;

				float lookupY = -(rayHitpointY.z+(planemod.y+sign.y*plane_offset.y)*PREMULT)-plane_correct.y;
				orthoLookup = vec2(rayHitpointY.x+windY.y*(GRASSDEPTH+rayHitpointY.z) ,lookupY);
 			
				plane_offset.y += PLANE_NUM_INV;  // increment/decrement to next grid plane on v axis
				zOffset = distance.y;	
  			}

			albedo += (1.0 - albedo.a) * textureGrad(albedo_sampler_1, orthoLookup, uv_dx[0], uv_dy[0]);

 	 		if (albedo.a &gt;= 0.49)
			{
				break;	//Early exit here
			}
  		}
	}

	albedo += (1.0-albedo.a)*AVERAGE_COLOR; //Fill remaining transparency in case there is some left. Can be replaced by a texture lookup
					   //into a fully opaque grass slice using orthoLookup.
#if	0
     color.xyz *= (vertColor.xyz); //Modulate with per vertex lightmap,as an alternative, modulate with N*L for dynamic lighting.

     //zOffset is along eye direction, transform and add to vertex position to get correct z-value.
     positionViewProj += mul(worldViewProj,view_dir.xzy*zOffset); 

     //Divide by homogenous part.
     depth = positionView.z/positionView.w;
#endif

	vec4 pos = projection_view_matrix[0] * vec4(world_position + view_dir.xzy * vec3(zOffset, zOffset, -zOffset) * 2, 1.0);

	//Divide by homogenous part.
	gl_FragDepth = 0.5 + 0.5 * pos.z/pos.w;

//	albedo = abs(vec4(pos.z/pos.w) - vec4(gl_FragCoord.z));
}
</source>
   <glsl_120>false</glsl_120>
   <glsl_130>true</glsl_130>
   <glsl_140>true</glsl_140>
   <glsl_150>true</glsl_150>
   <glsl_330>true</glsl_330>
  </shader_source_data>
 </shader_source_datas>
</shader_source>
