<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE boost_serialization>
<boost_serialization signature="serialization::archive" version="9">
<shader_source class_id="0" tracking_level="0" version="1">
	<px class_id="1" tracking_level="1" version="0" object_id="_0">
		<types class_id="2" tracking_level="0" version="0">
			<count>1</count>
			<item_version>0</item_version>
			<item>7</item>
		</types>
		<name class_id="3" tracking_level="0" version="0">
			<str>Cook-Torrance</str>
		</name>
		<datas class_id="4" tracking_level="0" version="0">
			<count>1</count>
			<item_version>0</item_version>
			<item class_id="5" tracking_level="0" version="0">
				<parameters class_id="6" tracking_level="0" version="0">
					<count>7</count>
					<item_version>0</item_version>
					<item class_id="7" tracking_level="0" version="0">
						<source>
							<str>Cook-Torrance_fragment_light</str>
						</source>
						<name>
							<str>diffuse_color</str>
						</name>
						<type>14</type>
						<qualifier>1</qualifier>
						<size>0</size>
						<scale>1</scale>
					</item>
					<item>
						<source>
							<str>Cook-Torrance_fragment_light</str>
						</source>
						<name>
							<str>fragment_normal</str>
						</name>
						<type>14</type>
						<qualifier>0</qualifier>
						<size>0</size>
						<scale>1</scale>
					</item>
					<item>
						<source>
							<str>Cook-Torrance_fragment_light</str>
						</source>
						<name>
							<str>light_color</str>
						</name>
						<type>15</type>
						<qualifier>0</qualifier>
						<size>0</size>
						<scale>1</scale>
					</item>
					<item>
						<source>
							<str>Cook-Torrance_fragment_light</str>
						</source>
						<name>
							<str>light_position</str>
						</name>
						<type>15</type>
						<qualifier>0</qualifier>
						<size>0</size>
						<scale>1</scale>
					</item>
					<item>
						<source>
							<str>Cook-Torrance_fragment_light</str>
						</source>
						<name>
							<str>specular_color</str>
						</name>
						<type>14</type>
						<qualifier>1</qualifier>
						<size>0</size>
						<scale>1</scale>
					</item>
					<item>
						<source>
							<str>Cook-Torrance_fragment_light</str>
						</source>
						<name>
							<str>world_position</str>
						</name>
						<type>14</type>
						<qualifier>0</qualifier>
						<size>0</size>
						<scale>1</scale>
					</item>
					<item>
						<source>
							<str>Cook-Torrance_fragment_light</str>
						</source>
						<name>
							<str>world_view_direction</str>
						</name>
						<type>15</type>
						<qualifier>0</qualifier>
						<size>0</size>
						<scale>1</scale>
					</item>
				</parameters>
				<version>0</version>
				<source>
					<str>vec3 dir, reflect_dir;
float dist, scale, nxdir, diffuse, specular, hxdir;

dir = light_position.xyz - world_position * light_color.a;
dist = dot(dir, dir);
dir = normalize(dir);
scale = max(0.0, 1.0 - dist * light_position.w);

float roughness_value = 0.9;
float ref_at_norm_incidence = 0.4;

// Compute any aliases and intermediary values
// -------------------------------------------
vec3 half_vector = normalize( dir + -world_view_direction.xyz );
float NdotL        = max(0.0, dot( fragment_normal, dir ) );
float NdotH        = max(0.0, dot( fragment_normal, half_vector ) );
float NdotV        = max(0.0, dot( fragment_normal, -world_view_direction.xyz ) );
float VdotH        = max(0.0, dot( -world_view_direction.xyz, half_vector ) );
float r_sq         = roughness_value * roughness_value;
 
 
 
// Evaluate the geometric term
// --------------------------------
float geo_numerator   = 2.0 * NdotH;
float geo_denominator = VdotH;
 
float geo_b = (geo_numerator * NdotV ) / geo_denominator;
float geo_c = (geo_numerator * NdotL ) / geo_denominator;
float geo   = min(1.0, min( geo_b, geo_c ) );
 
 
 
// Now evaluate the roughness term
// -------------------------------
float roughness;
 
float roughness_a = 1.0 / ( 4.0 * r_sq * pow( NdotH, 4 ) );
float roughness_b = NdotH * NdotH - 1.0;
float roughness_c = r_sq * NdotH * NdotH;
 
roughness = roughness_a * exp( roughness_b / roughness_c );
 
// Next evaluate the Fresnel value
// -------------------------------
float fresnel = pow(1.0 - VdotH, 5.0);
fresnel *= ( 1.0 - ref_at_norm_incidence );
fresnel += ref_at_norm_incidence;
 
 
 
// Put all the terms together to compute
// the specular term in the equation
// -------------------------------------
float Rs_numerator   = ( fresnel * geo * roughness );
float Rs_denominator  = NdotV * NdotL;
float Rs             = Rs_numerator/ Rs_denominator;
 
// Put all the parts together to generate
// the final colour
// --------------------------------------
diffuse_color = light_color.rgb * NdotL * scale;
specular_color = light_color.rgb * NdotL * Rs * scale;
</str>
				</source>
			</item>
		</datas>
	</px>
</shader_source>
</boost_serialization>

