<?xml version="1.0" encoding="utf8"?>
<shader_source>
 <name>terrain</name>
 <type>albedo_mapping</type>
 <shader_source_datas>
  <shader_source_data>
   <parameters>
    <parameter>
     <name>world_extra_uv</name>
     <type>vec2</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>6</scale>
    </parameter>
    <parameter>
     <name>terrain_sampler</name>
     <type>sampler3D</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>albedo</name>
     <type>vec4</type>
     <qualifier>out</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>world_uv</name>
     <type>vec2</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
   </parameters>
   <source>vec4 tmp;
vec2 uv, ddx, ddy;
float lod, blend;
int i, index;

ddx = dFdx(world_uv);
ddy = dFdy(world_uv);

lod = log2(max(length(ddx), length(ddy)));

index = 5;

for (i = 0; i &lt; 5; ++i)
{
	uv = world_extra_uv[i];

	if (all(lessThan(abs(uv - vec2(0.5)), vec2(0.4995))))
	{
		index = i;

		break;
	}
}

lod = clamp(lod, index, 5.0);
index = int(lod);
blend = fract(lod);

albedo = texture3D(terrain_sampler, vec3(world_extra_uv[index], (index + 0.5) / 6.0));

if (blend &gt; 0.0)
{
	tmp = texture3D(terrain_sampler, vec3(world_extra_uv[index + 1], (index + 1.5) / 6.0));
	albedo = mix(albedo, tmp, blend);
}
</source>
   <glsl_120>true</glsl_120>
   <glsl_130>false</glsl_130>
   <glsl_140>false</glsl_140>
   <glsl_150>false</glsl_150>
   <glsl_330>false</glsl_330>
  </shader_source_data>
  <shader_source_data>
   <parameters>
    <parameter>
     <name>world_extra_uv</name>
     <type>vec2</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>6</scale>
    </parameter>
    <parameter>
     <name>world_uv</name>
     <type>vec2</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>terrain_sampler</name>
     <type>sampler2DArray</type>
     <qualifier>in</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
    <parameter>
     <name>albedo</name>
     <type>vec4</type>
     <qualifier>out</qualifier>
     <size>one</size>
     <scale>1</scale>
    </parameter>
   </parameters>
   <source>vec4 tmp;
vec2 uv, ddx, ddy;
float lod, blend;
float det, squared_length_major, length_major;
float ratio_of_anisotropy, length_minor;
int i, index;

ddx = dFdx(world_uv);
ddy = dFdy(world_uv);

squared_length_major = max(dot(ddx, ddx), dot(ddy, ddy));
det = abs(ddx.x * ddy.y - ddx.y * ddy.x);
length_major = sqrt(squared_length_major);
ratio_of_anisotropy = squared_length_major / det;
length_minor = max((ratio_of_anisotropy &gt; 16.0) ? length_major / ratio_of_anisotropy : det / length_major, 1.0);
lod = log2(length_minor);

ddx = dFdx(world_extra_uv[0]);
ddy = dFdy(world_extra_uv[0]);

index = 5;

for (i = 0; i &lt; 5; ++i)
{
	uv = world_extra_uv[i];

	if (all(lessThan(abs(uv - vec2(0.5)), vec2(0.4995))))
	{
		index = i;

		break;
	}
}

lod = clamp(lod, index, 5.0);
index = int(lod);
blend = fract(lod);

ddx /= exp2(index);
ddy /= exp2(index);

albedo = textureGrad(terrain_sampler, vec3(world_extra_uv[index], index), ddx, ddy);

if (blend &gt; 0.0)
{
	ddx *= 0.5;
	ddy *= 0.5;

	tmp = textureGrad(terrain_sampler, vec3(world_extra_uv[index + 1], index + 1), ddx, ddy);
	albedo = mix(albedo, tmp, blend);
}
</source>
   <glsl_120>false</glsl_120>
   <glsl_130>true</glsl_130>
   <glsl_140>true</glsl_140>
   <glsl_150>true</glsl_150>
   <glsl_330>true</glsl_330>
  </shader_source_data>
 </shader_source_datas>
</shader_source>
