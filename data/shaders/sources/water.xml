<?xml version="1.0" encoding="utf8"?>
<shader_source>
 <name>water</name>
 <type>main_effect</type>
 <shader_source_datas>
  <shader_source_data>
   <parameters>
    <parameter>
     <common_parameter>albedo</common_parameter>
     <qualifier>out</qualifier>
    </parameter>
    <parameter>
     <sampler_parameter>effect_sampler_0</sampler_parameter>
     <type>sampler2D</type>
    </parameter>
    <parameter>
     <sampler_parameter>effect_sampler_1</sampler_parameter>
     <type>sampler2D</type>
    </parameter>
    <parameter>
     <sampler_parameter>effect_sampler_2</sampler_parameter>
     <type>sampler2D</type>
    </parameter>
    <parameter>
     <sampler_parameter>effect_sampler_3</sampler_parameter>
     <type>samplerCube</type>
    </parameter>
    <parameter>
     <common_parameter>emission</common_parameter>
     <qualifier>out</qualifier>
    </parameter>
    <parameter>
     <common_parameter>fragment_normal</common_parameter>
     <qualifier>out</qualifier>
    </parameter>
    <parameter>
     <common_parameter>gloss</common_parameter>
     <qualifier>out</qualifier>
    </parameter>
    <parameter>
     <common_parameter>specular</common_parameter>
     <qualifier>out</qualifier>
    </parameter>
    <parameter>
     <auto_parameter>time</auto_parameter>
    </parameter>
    <parameter>
     <common_parameter>world_position</common_parameter>
     <qualifier>in</qualifier>
    </parameter>
    <parameter>
     <common_parameter>world_uv</common_parameter>
     <qualifier>in</qualifier>
    </parameter>
    <parameter>
     <common_parameter>world_view_direction</common_parameter>
     <qualifier>in</qualifier>
    </parameter>
   </parameters>
   <source>mat2 rotation;
vec4 sample;
vec3 normal, reflect_dir;
vec2 normal_0, normal_1, normal_2, normal_3, normal_4, normal_5, normal_6;
vec2 ff, ff_scale, offset, flow_dir, uv, flow_uv;

flow_uv = world_position.xy - vec2(0.5);
uv = world_uv;

// ff is the factor that blends the tiles.
ff = abs(2.0 * fract(flow_uv + 0.5) - 1.0) - 0.5;

// take a third power, to make the area with more or less equal contribution
// of more tile bigger
ff = 0.5 - 4.0 * ff * ff * ff;

// ffscale is a scaling factor that compensates for the effect that
// adding normal vectors together tends to get them closer to the average normal
// which is a visible effect. For more or less random waves, this factor
// compensates for it 
ff_scale = sqrt(ff * ff + (1.0 - ff) * (1.0 - ff));

sample = texture(effect_sampler_2, (flow_uv + vec2(1.0) + ivec2(0, 0)) / textureSize(effect_sampler_2, 0).xy);
flow_dir = (sample.b + 1.0) * normalize(sample.xy - 0.5) * 0.5;
offset = vec2(time * 0.05, 0.0);// * sample.a;

// build the rotation matrix that rotates the complete tile
rotation = mat2(flow_dir.x, -flow_dir.y, flow_dir.y, flow_dir.x);

// this is the normal for tile A
normal_0 = texture(effect_sampler_1, rotation * uv - offset).rg;

sample = texture(effect_sampler_2, (flow_uv + vec2(1.0) + ivec2(1, 0)) / textureSize(effect_sampler_2, 0).xy);
flow_dir = (sample.b + 1.0) * normalize(sample.xy - 0.5) * 0.5;
offset = vec2(time * 0.05, 0.0);// * sample.a;

// build the rotation matrix that rotates the complete tile
rotation = mat2(flow_dir.x, -flow_dir.y, flow_dir.y, flow_dir.x);

// this is the normal for tile B
normal_1 = texture(effect_sampler_1, rotation * uv - offset * 1.06 + 0.62).rg;

sample = texture(effect_sampler_2, (flow_uv + vec2(1.0) + ivec2(0, 1)) / textureSize(effect_sampler_2, 0).xy);
flow_dir = (sample.b + 1.0) * normalize(sample.xy - 0.5) * 0.5;
offset = vec2(time * 0.05, 0.0);// * sample.a;

// build the rotation matrix that rotates the complete tile
rotation = mat2(flow_dir.x, -flow_dir.y, flow_dir.y, flow_dir.x);

// this is the normal for tile C
normal_2 = texture(effect_sampler_1, rotation * uv - offset * 1.33 + 0.27).rg;

sample = texture(effect_sampler_2, (flow_uv + vec2(1.0) + ivec2(1, 1)) / textureSize(effect_sampler_2, 0).xy);
flow_dir = (sample.b + 1.0) * normalize(sample.xy - 0.5) * 0.5;
offset = vec2(time * 0.05, 0.0);// * sample.a;

// build the rotation matrix that rotates the complete tile
rotation = mat2(flow_dir.x, -flow_dir.y, flow_dir.y, flow_dir.x);

// this is the normal for tile C
normal_3 = texture(effect_sampler_1, rotation * uv - offset * 1.24).rg;

normal_4 = mix(normal_1, normal_0, ff.x);
normal_5 = mix(normal_2, normal_3, ff.x);
normal_6 = mix(normal_5, normal_4, ff.y);

normal_6 = (normal_6 - 0.5) / (ff_scale.y * ff_scale.x);

normal_6 *= 0.3;
normal.xy = normal_6;
normal.z = sqrt(1.0 - dot(normal_6, normal_6));

reflect_dir = reflect(world_view_direction.xyz, normal);

float a = 0.95 - 0.6 * pow(dot(normal, -world_view_direction.xyz), 2.0);

albedo.rgb = texture(effect_sampler_3, reflect_dir).rgb;
albedo.a = a;
emission = vec3(0.0);
specular = albedo.rgb * 0.5;
albedo.rgb *= 0.5;
gloss = 1.0 - dot(fwidth(flow_uv), vec2(1.0));

fragment_normal = normal;
</source>
   <version>130</version>
   <shader_types>fragment</shader_types>
  </shader_source_data>
  <shader_source_data>
   <parameters>
    <parameter>
     <common_parameter>albedo</common_parameter>
     <qualifier>out</qualifier>
    </parameter>
    <parameter>
     <sampler_parameter>effect_sampler_0</sampler_parameter>
     <type>sampler2D</type>
    </parameter>
    <parameter>
     <common_parameter>emission</common_parameter>
     <qualifier>out</qualifier>
    </parameter>
    <parameter>
     <common_parameter>fragment_normal</common_parameter>
     <qualifier>out</qualifier>
    </parameter>
    <parameter>
     <common_parameter>gloss</common_parameter>
     <qualifier>out</qualifier>
    </parameter>
    <parameter>
     <common_parameter>specular</common_parameter>
     <qualifier>out</qualifier>
    </parameter>
    <parameter>
     <common_parameter>world_normal</common_parameter>
     <qualifier>in</qualifier>
    </parameter>
    <parameter>
     <common_parameter>world_uv</common_parameter>
     <qualifier>in</qualifier>
    </parameter>
   </parameters>
   <source>albedo = texture2D(effect_sampler_0, world_uv);
emission = vec3(0.0);
specular = vec3(0.0);
gloss = 0.0;
fragment_normal = normalize(world_normal);
</source>
   <version>120</version>
   <shader_types>fragment</shader_types>
  </shader_source_data>
 </shader_source_datas>
</shader_source>
