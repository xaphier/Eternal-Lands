/****************************************************************************
 *            texturecache.cpp
 *
 * Author: 2011  Daniel Jungmann <el.3d.source@googlemail.com>
 * Copyright: See COPYING file that comes with this distribution
 ****************************************************************************/

#include "texturecache.hpp"
#include "texture.hpp"
#include "image.hpp"
#include "exceptions.hpp"
#include "codec/codecmanager.hpp"
#include "logging.hpp"
#include "filesystem.hpp"

namespace eternal_lands
{

	namespace
	{

		/* GIMP RGB C-Source image dump 1-byte-run-length-encoded */
		const Uint32 image_width = 32;
		const Uint32 image_height = 32;
		const Uint8 rle_pixel_data[460] =
		{
			0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 
			0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x84, 0xff, 
			0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x83, 0xff, 0x00, 
			0x00, 0x83, 0x00, 0x00, 0x00, 0x83, 0xff, 0x00, 0x00, 
			0x84, 0x00, 0x00, 0x00, 0x84, 0xff, 0x00, 0x00, 0x83, 
			0x00, 0x00, 0x00, 0x83, 0xff, 0x00, 0x00, 0x83, 0x00, 
			0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x85, 0x00, 0x00, 
			0x00, 0x01, 0xff, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 
			0x01, 0xff, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x01, 
			0xff, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x01, 0xff, 
			0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 
			0x00, 0x84, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 
			0x82, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x82, 
			0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x82, 0x00, 
			0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x85, 0x00, 0x00, 
			0x00, 0x01, 0xff, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 
			0x01, 0xff, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x01, 
			0xff, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x01, 0xff, 
			0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 
			0x00, 0x84, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 
			0x82, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x82, 
			0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x82, 0x00, 
			0x00, 0x00, 0x83, 0xff, 0x00, 0x00, 0x83, 0x00, 0x00, 
			0x00, 0x83, 0xff, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
			0x83, 0xff, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x01, 
			0xff, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x01, 0xff, 
			0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x83, 0xff, 0x00, 
			0x00, 0x83, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 
			0x85, 0x00, 0x00, 0x00, 0x03, 0xff, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0xff, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
			0x03, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 
			0x00, 0x83, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 
			0x84, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x82, 
			0x00, 0x00, 0x00, 0x03, 0xff, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0xff, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x01, 
			0xff, 0x00, 0x00, 0x85, 0x00, 0x00, 0x00, 0x01, 0xff, 
			0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 
			0x00, 0x82, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 
			0x82, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x82, 
			0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x84, 0x00, 
			0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x82, 0x00, 0x00, 
			0x00, 0x01, 0xff, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 
			0x01, 0xff, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x84, 
			0xff, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x01, 0xff, 
			0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x03, 0xff, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x83, 0x00, 
			0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x82, 0x00, 0x00, 
			0x00, 0x84, 0xff, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
			0x01, 0xff, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x01, 
			0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 
			0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xa3, 0x00, 0x00, 
			0x00
		};

		void rle_decode(const Uint8* input,
			AbstractWriteMemoryBuffer &buffer)
		{
			Uint64 src, dst, len, size;
			Uint8* ptr;

			src = 0;
			dst = 0;

			ptr = static_cast<Uint8*>(buffer.get_ptr());
			size = buffer.get_size();

			while (dst < size)
			{
				len = input[src];
				src++;

				if (len & 128)
				{
					len = len - 128;

					while (len > 0)
					{
						memcpy(&ptr[dst], &input[src],
							3);
						dst += 3;
						len--;
					}

					src += 3;
				}
				else
				{
					len *= 3;

					memcpy(&ptr[dst], &input[src], len);

					dst += len;
					src += len;
				}
			}
		}

		TextureSharedPtr build_error_texture()
		{
			Uint32Array3 sizes;
			ImageSharedPtr image;
			TextureSharedPtr texture;

			sizes[0] = image_width;
			sizes[1] = image_height;
			sizes[2] = 1;

			image = boost::make_shared<Image>(String(L"error"),
				false, tft_rgb8, sizes, 0);

			rle_decode(rle_pixel_data, image->get_buffer());

			texture = boost::make_shared<Texture>(String(L"error"));
			texture->set_format(image->get_texture_format());
			texture->set_image(image);

			return texture;
		}

	}

	TextureCache::TextureCache(const CodecManagerWeakPtr &codec_manager,
		const FileSystemWeakPtr &file_system):
		m_codec_manager(codec_manager), m_file_system(file_system)
	{
		assert(!m_codec_manager.expired());
		assert(!m_file_system.expired());
	}

	TextureCache::~TextureCache() throw()
	{
	}

	const TextureSharedPtr &TextureCache::get_error_texture()
	{
		if (m_error_texture.get() == 0)
		{
			m_error_texture = build_error_texture();
		}

		return m_error_texture;
	}

	TextureSharedPtr TextureCache::do_load_texture(const String &name) const
	{
		ImageSharedPtr image;
		TextureSharedPtr texture;
		ReaderSharedPtr reader;
		ImageCompressionTypeSet compressions;

		if (GLEW_EXT_texture_compression_s3tc)
		{
			compressions.insert(ict_s3tc);
		}

		if (GLEW_EXT_texture_compression_rgtc)
		{
			compressions.insert(ict_rgtc);
		}

		reader = get_file_system()->get_file(name);

		image = get_codec_manager()->load_image(reader, compressions);
		texture = boost::make_shared<Texture>(name);
		texture->set_format(image->get_texture_format());
		texture->set_image(image);

		return texture;
	}

	TextureSharedPtr TextureCache::load_texture(const String &name)
	{
		try
		{
			return do_load_texture(name);
		}
		catch (boost::exception &exception)
		{
			LOG_EXCEPTION(exception);
		}
		catch (std::exception &exception)
		{
			LOG_EXCEPTION(exception);
		}

		return get_error_texture();
	}

	const TextureSharedPtr &TextureCache::get_texture(const String &name)
	{
		TextureSharedPtr texture;
		TextureCacheMap::iterator found;
		StringType str;
		Uint32 size;

		str = name;

		size = str.size();

		str[size - 1] = 's';
		str[size - 2] = 'd';
		str[size - 3] = 'd';

		found = m_texture_cache.find(String(str));

		if (found == m_texture_cache.end())
		{
			texture = load_texture(String(str));

			m_texture_cache[String(str)] = texture;

			return m_texture_cache[String(str)];
		}
		else
		{
			return found->second;
		}
	}

}
